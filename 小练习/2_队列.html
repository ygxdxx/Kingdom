<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>队列</title></head><body></body><script>    //队列为FIFO结构    //实现enqueue、dequeue、front（peek）、isEmpty、size方法    function Queue() {        let items = [];        this.enqueue = function (element) {            items.push(element);        };        this.dequeue = function () {            return items.shift();        };        this.front = function () {            if (this.isEmpty()) {                return null;            }            return items[0];        };        this.isEmpty = function () {            return items.length === 0;        };        this.size = function () {            return items.length;        };        this.print = function () {            console.log(items.toString());        }    }    // ==== 测试 ====    let queue = new Queue();    console.log(queue.isEmpty());    queue.enqueue('John');    queue.enqueue('Jack');    queue.enqueue('Camila');    queue.print();    console.log(queue.size());    console.log(queue.isEmpty());    queue.dequeue();    queue.dequeue();    queue.print();    // 带有优先级的队列PriorityQueue    // 优先级数字越小代表优先级越高    // 插入过程中，除了数据之外需要单独一个priority属性表示当前数据的优先级    function PriorityQueue() {        let items = [];        function QueueElement(element, priority) {            this.element = element;            this.priority = priority;        }        this.enqueue = function (element, priority) {            let queueElement = new QueueElement(element, priority);            if (this.isEmpty()) {                items.push(queueElement);            } else {                let added = false;                for (let i = 0; i < items.length; i++) {                    if (queueElement.priority < items[i].priority) {                        items.splice(i, 0, queueElement);                        added = true;                        break;                    }                }                if (!added) {                    items.push(queueElement);                }            }        };        this.dequeue = function () {            return items.shift();        };        this.isEmpty = function () {            return items.length === 0;        };        this.print = function () {            items.forEach((item, index) => {                console.log(item.element);            });        };    }    // ==== 测试 ====    let priorityQueue = new PriorityQueue();    priorityQueue.enqueue('John', 2);    priorityQueue.enqueue('Jack', 1);    priorityQueue.enqueue('Camila', 1);    priorityQueue.print();    //循环队列    //击鼓传花游戏    function hotPotato(nameList, num) {        let queue = new Queue();        for (let i = 0; i < nameList.length; i++) {            queue.enqueue(nameList[i]);        }        while (queue.size() > 1) {            for (let i = 0; i < num; i++) {                queue.enqueue(queue.dequeue());            }            let eliminatedPerson = queue.dequeue();            console.log(eliminatedPerson + '淘汰');        }        return queue.dequeue();    }    let names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl'];    let winner = hotPotato(names, 7);    console.log('胜利者是：' + winner);</script></html>